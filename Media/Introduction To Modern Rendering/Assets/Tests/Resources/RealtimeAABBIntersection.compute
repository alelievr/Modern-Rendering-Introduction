#pragma kernel CSMain

RWTexture2D<float4> _Output;

#pragma enable_d3d11_debug_symbols

StructuredBuffer<float3> _AABBs;
int _AABBCount;
float3 _RayOrigin;

#define EPSILON 1e-7

struct AABB
{
    float3 min;
    float3 max;
};

bool TestSegmentAABB(float3 p0, float3 p1, AABB b)
{
    float3 e = b.max - b.min;
    float3 d = p1 - p0;
    float3 m = p0 + p1 - (float3)b.min - (float3)b.max;// Try world coordinate axes as separating axes
    float adx = abs(d.x);
    if (abs(m.x) > e.x + adx) return false;
    float ady = abs(d.y);
    if (abs(m.y) > e.y + ady) return false;
    float adz = abs(d.z);
    if (abs(m.z) > e.z + adz) return false;
    // Add in an epsilon term to counteract arithmetic errors when segment is
    // (near) parallel to a coordinate axis (see text for detail)
    adx += EPSILON; ady += EPSILON; adz += EPSILON;
    // Try cross products of segment direction vector with coordinate axes
    if (abs(m.y * d.z - m.z * d.y) > e.y * adz + e.z * ady) return false;
    if (abs(m.z * d.x - m.x * d.z) > e.x * adz + e.z * adx) return false;
    if (abs(m.x * d.y - m.y * d.x) > e.x * ady + e.y * adx) return false;
    // No separating axis found; segment must be overlapping AABB
    return true;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float width, height;
    _Output.GetDimensions(width, height);
    float2 uv = float2(id.x / width, id.y / height);
    // 90 degree fov
    float3 dir = normalize(float3(uv.x * 2 - 1, uv.y * 2 - 1, -1));

    float t, u, v;
    float hit = 0;

    float3 p0 = _RayOrigin;
    float3 p1 = _RayOrigin - dir * 1000;
    for (int i = 0; i < _AABBCount; i++)
    {
        AABB aabb;
        aabb.min = _AABBs[i * 2 + 0];
        aabb.max = _AABBs[i * 2 + 1];
        if (TestSegmentAABB(p0, p1, aabb))
            hit++;
    }

    // _Output[id.xy] = float4(t, u, v, 1.0);
    _Output[id.xy] = float4(hit / float(_AABBCount).xxx, 1);
}
