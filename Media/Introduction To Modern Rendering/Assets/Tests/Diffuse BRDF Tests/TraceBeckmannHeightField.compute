#pragma kernel Trace
#pragma kernel ClearLUT

#pragma target 5.0

#pragma enable_d3d11_debug_symbols

#include "DebugLines.hlsl"
#include "Random.hlsl"

#define PI 3.14159265358979323846

Texture2D<float> _HeightField;
SamplerState sampler_HeightField;
RWTexture3D<float2> _OutputLUT;

RWTexture2D<float4> _DebugTrace;

int  _MaxBounces;
float _Roughness;
float3 _RayDir;

float2 _DebugCursorPosition;

uint3 _LUTSize;

float SampleHeightField(float2 uv)
{
    // The values in the height field are in the range of around +5 to -5
    float h = _HeightField.SampleLevel(sampler_HeightField, uv + 0.5, 0);

    // Scale back to approximately 0 to 1
    float h01 = (h + 5) * 0.1;

    return h01;
}

// naive ray‐march against the height field
float IntersectHeightField(float3 origin, float3 dir)
{
    float stepSize = 0.001;
    float t = 0;

    for (int i = 0; i < 5000; ++i)
    {
        float3 p = origin + t * dir;

        // We remove 1 because the height field is below the plane (to match the POM visualization)
        float h = SampleHeightField(p.xz) - 1;
        if (p.y < h)
        {
            // If we return this distance, the next point will be under the surface,
            // so we need to offset it a bit before continuing.
            return t - stepSize * 2;
        }

        // If we're above the surface, it means that the ray bounced back so we can stop
        if (p.y > 0.01 && dir.y > 0)
            return -1;

        t += stepSize;
    }
    return -1;
}

float3 GetHeightFieldNormal(float2 pos)
{
	float2 eps = float2(0.01, 0);

	float HXn = SampleHeightField(pos - eps.xy);
	float HXp = SampleHeightField(pos + eps.xy);
	float HYn = SampleHeightField(pos - eps.yx);
	float HYp = SampleHeightField(pos + eps.yx);

	return normalize(float3( HXn - HXp, HYn - HYp, 2.0 * eps.x));
}

// Build orthonormal basis from a 3D Unit Vector Without normalization
// https://backend.orbit.dtu.dk/ws/portalfiles/portal/126824972/onb_frisvad_jgt2012_v2.pdf
void BuildOrthonormalBasis(float3 normal, out float3 tangent, out float3 biTangent)
{
    float a = normal.z > -0.9999999f ? 1.0f / (1.0f + normal.z) : 0.0f;
    float b = -normal.x * normal.y * a;

    tangent = float3(1.0f - normal.x * normal.x * a, b, -normal.x);
    biTangent = float3(b, 1.0f - normal.y * normal.y * a, -normal.y);
}

// Generate a random direction on the hemisphere using the cosine-weighted distribution
float3 GetRandomDirection(float3 normal)
{
    // Bounce off the surface using random direction
    float3 tangent, biTangent;
    BuildOrthonormalBasis(normal, tangent, biTangent);

    float r1 = NextRandomFloat();
    float r2 = NextRandomFloat();

    float	cosTheta = sqrt(r1);
    float	sinTheta = sqrt(1.0 - r1);
    float2	scPhi;
    sincos( 2.0 * PI * r2, scPhi.x, scPhi.y );

    float3	lsDirection = float3(sinTheta * scPhi.x, sinTheta * scPhi.y, cosTheta);

    return normalize(lsDirection.x * tangent + lsDirection.y * biTangent + lsDirection.z * normal);
}


[numthreads(8,8,1)]
void Trace(uint3 id : SV_DispatchThreadID)
{
    InitRandomSeed(uint4(id, 0));

    uint2 heightFieldDimensions;
    _HeightField.GetDimensions(heightFieldDimensions.x, heightFieldDimensions.y);

    float3 N = float3(0, 1, 0); // normal in the XZ plane
    float2 uv = (float2(id.xy) + 0.5) / (float)heightFieldDimensions.xy;
    
    float NdotL = dot(N, -_RayDir);

    // Clear debug
    _DebugTrace[id.xy] = 0;
    bool isDebugThread = id.x == (uint)_DebugCursorPosition.x && id.y == (uint)_DebugCursorPosition.y;

    isDebugThread = id.x == 512 && id.y == 512;

    // If the light is below the surface, we can skip it because we're only looking at direct diffuse interactions
    if (NdotL < 0)
        return;
    
    // TODO: make the rays start form a plane towards the patch (each ray has 1 px)
    float3 up    = normalize(cross(float3(0, 0, 1), _RayDir));
    float3 right = normalize(cross(up, _RayDir));
    float2 p = uv - 0.5;
    float3 rayOrigin = -_RayDir + right * right.z * p.x + up * up.x * p.y;

    // Intersect with a plane to get closer before starting the ray march
    float3 pos = rayOrigin;
    float3 dir = normalize(_RayDir);

    float denom = dot(N, _RayDir);
    if (abs(denom) > 1e-5)
    {
        float t = -dot(N, rayOrigin) / denom;
        pos = rayOrigin + t * _RayDir;
    }

    pos.y = 0.0;
    rayOrigin = pos;

    float lastHeight = -5;
    float3 lastNormal = float3(0, 1, 0);
    [loop]
    for (int bounce = 0; bounce < _MaxBounces; ++bounce)
    {
        // ray‐march / height field intersection
        float t = IntersectHeightField(pos, dir);
        
        // Debug ray tracing code
        if (isDebugThread)
        {
            float d = t > 0 ? t : 1;
            AddDebugLine(pos, pos + dir * d, float4(1, 0, 0, 1));
        }

        if (t < 0) break;

        // Place starting point at the intersection
        pos += t * dir;

        float h = SampleHeightField(pos.xz);
        lastHeight = h;

        // Calculate height field normal
        float3 normal = GetHeightFieldNormal(pos.xz);

        lastNormal = normal;
        
        // TODO: calculate bounce direction using lambertian reflector instead of mirror
        dir = GetRandomDirection(normal);
    }

    // Compute the output coordinates in the LUT between 0 and 1
    float3 outputPosition = float3(
        NdotL * 0.5 + 0.5, // N.L
        dot(-_RayDir, dir) * 0.5 + 0.5, // L.V
        _Roughness
    );

    float debug = 1 - lastHeight;
    debug = length(pos - rayOrigin) / 5;

    _DebugTrace[id.xy] = float4(debug, debug, debug, 1); // debug output to visualize the trace
    // _DebugTrace[id.xy] = float4(lastNormal, 1); // debug output to visualize the trace

    // TODO:
    // _OutputLUT[(uint3)(outputPosition * _LUTSize)] += 1;
}

[numthreads(8,8,8)]
void ClearLUT(uint3 id : SV_DispatchThreadID)
{
    uint3 dimensions;
    _OutputLUT.GetDimensions(dimensions.x, dimensions.y, dimensions.z);

    if (id.x >= dimensions.x || id.y >= dimensions.y || id.z >= dimensions.z)
        return;

    _OutputLUT[id] = float2(0, 0);

    if (id.x == 0 && id.y == 0 && id.z == 0)
        _IndirectLineDrawArgs[0].instanceCount = 0;
}
